
(in-package :mabu)

(declaim (optimize debug))

(defun tree-length (list &optional (acc 0))
  (cond ((null list) acc)
        ((consp (car list)) (tree-length (rest list) (+ acc (tree-length (car list)))))
        (t (tree-length (rest list) (1+ acc)))))

(defun diff-score (instructions &optional (acc 0) (last nil))
  (cond ((null instructions) acc)
        (t (destructuring-bind (op arg) (car instructions)
             (ecase op
               ((keep) (diff-score (cdr instructions)
                                   (+ acc (if (eq last 'keep)
                                              0
                                              1))
                                   'keep))
               ((drop) (diff-score (cdr instructions)
                                   (+ acc (if (eq last 'drop)
                                              0
                                              1))
                                   'drop))
               ((add) (diff-score (cdr instructions)
                                  (+ acc (tree-length arg))
                                  'add))
               ((into) (diff-score (cdr instructions)
                                   (+ acc (diff-score arg))
                                   'into)))))))

(defun longest-subseq (seq1 seq2 &optional acc)
  (cond ((and (null seq1) (null seq2))
         (reverse acc))
        ((null seq1)
         (longest-subseq nil nil (cons (list 'add seq2)
                                       acc)))
        ((null seq2)
         (longest-subseq nil nil (cons (list 'drop (length seq1))
                                       acc)))
        ((equalp (first seq1) (first seq2))
         (longest-subseq (rest seq1) (rest seq2) (cons (list 'keep 1) acc)))
        (t
         (let ((candidates (list (longest-subseq seq1
                                                 (rest seq2)
                                                 (cons (list 'add (list (first seq2)))
                                                       acc))
                                 (longest-subseq (rest seq1)
                                                 seq2
                                                 (cons (list 'drop 1)
                                                       acc)))))
           (if (and (consp (car seq1))
                    (consp (car seq2)))
               (push (longest-subseq (rest seq1)
                                     (rest seq2)
                                     (cons (list 'into (longest-subseq (car seq1)
                                                                       (car seq2)))
                                           acc))
                     candidates))
           (setf candidates (mapcar #'(lambda (diff) (cons (diff-score diff) diff))
                                    candidates))
           (setf candidates (sort candidates #'< :key #'car))
           (-> candidates first cdr)))))

(defun group-by-impl (seq pred acc current-group)
  (cond ((null seq) (if current-group
                        (reverse (cons (reverse current-group) acc))
                        acc))
        ((and current-group (funcall pred (first seq) (first current-group)))
         (group-by-impl (rest seq) pred acc (cons (first seq) current-group)))
        ((and current-group (not (funcall pred (first seq) (first current-group))))
         (group-by-impl (rest seq) pred (cons (reverse current-group) acc) (list (first seq))))
        (t (group-by-impl (rest seq) pred acc (list (first seq))))))

(defun group-by (seq &key (predicate #'equal))
  (group-by-impl seq predicate nil nil))

(defun list-diff (list1 list2)
  (labels ((combine (seq)
             (unless (consp (car seq))
               (error "Incorrect diff."))
             (ecase (-> seq first first)
               ((keep) (list 'keep (reduce #'+ (mapcar #'second seq))))
               ((drop) (list 'drop (reduce #'+ (mapcar #'second seq))))
               ((add) (list 'add (apply #'append (mapcar #'second seq))))
               ((into) (first seq))))
           (rle-compress (diff)
             (-> diff
                 (group-by $ :predicate (lambda (e1 e2)
                                          (cond ((and (consp e1)
                                                      (consp e2)
                                                      (-> e1 first (eq $ 'into) not))
                                                 (eq (car e1) (car e2)))
                                                (t (equal e1 e2)))))
                 (mapcar #'combine $)
                 (mapcar (lambda (elem)
                           (if (eq 'into (first elem))
                               (list 'into (rle-compress (second elem)))
                               elem))
                         $))))
    (rle-compress (longest-subseq list1 list2))))

(defun list-patch (list diff &optional acc)
  (cond ((null diff) (apply #'append (reverse acc)))
        (t (destructuring-bind (op arg) (car diff)
             (ecase op
               ((keep) (list-patch (nthcdr arg list)
                                   (cdr diff)
                                   (cons (subseq list 0 arg)
                                         acc)))
               ((add) (list-patch list
                                  (cdr diff)
                                  (cons arg acc)))
               ((drop) (list-patch (nthcdr arg list)
                                   (cdr diff)
                                   acc))
               ((into) (list-patch (cdr list)
                                   (cdr diff)
                                   (cons (list (list-patch (car list)
                                                           (-> diff first second)))
                                         acc))))))))

