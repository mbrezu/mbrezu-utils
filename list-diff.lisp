
(in-package :mabu)

(declaim (optimize debug))

(defun tree-length (list &optional (acc 0))
  (cond ((null list) acc)
        ((atom list) (+ acc 1))
        ((consp (car list)) (tree-length (cdr list) (+ acc (tree-length (car list)))))
        (t (tree-length (cdr list) (1+ acc)))))

(defun diff-score (instructions &optional (acc 0) (last nil))
  (cond ((null instructions) acc)
        (t (ematch (car instructions)
             ((list :keep arg) (diff-score (cdr instructions)
                                           (+ acc (if (eq last :keep)
                                                      0
                                                      1))
                                           :keep))
             ((list :drop arg) (diff-score (cdr instructions)
                                           (+ acc (if (eq last :drop)
                                                      0
                                                      1))
                                           :drop))
             ((list :add arg) (diff-score (cdr instructions)
                                          (+ acc (tree-length arg))
                                          :add))
             ((list :into arg) (diff-score (cdr instructions)
                                           (+ acc (diff-score arg))
                                           :into))
             (:drop-tail (diff-score (cdr instructions)
                                     (1+ acc)))
             (:keep-tail (diff-score (cdr instructions)
                                     (1+ acc)))
             ((list :replace-tail arg) (diff-score (cdr instructions)
                                                   (+ acc 1 (tree-length arg))))
             ((list :add-tail arg) (diff-score (cdr instructions)
                                               (+ acc (tree-length arg))))))))

(defun longest-subseq (seq1 seq2 &optional acc)
  (cond ((and (null seq1) (null seq2))
         (reverse acc))
        ((not (listp seq1))
         (cond ((or (null seq2) (consp seq2))
                (longest-subseq nil seq2 (cons :drop-tail acc)))
               ((equalp seq1 seq2)
                (longest-subseq nil nil (cons :keep-tail acc)))
               (t (longest-subseq nil nil (cons (list :replace-tail seq2)
                                                acc)))))
        ((not (listp seq2))
         (cond ((null seq1)
                (longest-subseq nil nil (cons (list :add-tail seq2) acc)))
               (t (longest-subseq (rest seq1) seq2 (cons (list :drop 1)
                                                         acc)))))
        ((null seq1)
         (longest-subseq nil (rest seq2) (cons (list :add (list (car seq2)))
                                               acc)))
        ((null seq2)
         (longest-subseq (rest seq1) nil (cons (list :drop 1)
                                               acc)))
        ((equalp (first seq1) (first seq2))
         (longest-subseq (rest seq1) (rest seq2) (cons (list :keep 1) acc)))
        (t
         (let ((candidates (list (longest-subseq seq1
                                                 (rest seq2)
                                                 (cons (list :add (list (first seq2)))
                                                       acc))
                                 (longest-subseq (rest seq1)
                                                 seq2
                                                 (cons (list :drop 1)
                                                       acc)))))
           (if (and (consp (car seq1))
                    (consp (car seq2)))
               (push (longest-subseq (rest seq1)
                                     (rest seq2)
                                     (cons (list :into (longest-subseq (car seq1)
                                                                       (car seq2)))
                                           acc))
                     candidates))
           (setf candidates (mapcar #'(lambda (diff) (cons (diff-score diff) diff))
                                    candidates))
           (setf candidates (sort candidates #'< :key #'car))
           (-> candidates first cdr)))))

(defun group-by-impl (seq pred acc current-group)
  (cond ((null seq) (if current-group
                        (reverse (cons (reverse current-group) acc))
                        acc))
        ((and current-group (funcall pred (first seq) (first current-group)))
         (group-by-impl (rest seq) pred acc (cons (first seq) current-group)))
        ((and current-group (not (funcall pred (first seq) (first current-group))))
         (group-by-impl (rest seq) pred (cons (reverse current-group) acc) (list (first seq))))
        (t (group-by-impl (rest seq) pred acc (list (first seq))))))

(defun group-by (seq &key (predicate #'equal))
  (group-by-impl seq predicate nil nil))

(defun list-diff (list1 list2)
  (labels ((combine (seq)
             (ematch (car seq)
               ((list :keep _) (list :keep (reduce #'+ (mapcar #'second seq))))
               ((list :drop _) (list :drop (reduce #'+ (mapcar #'second seq))))
               ((list :add _) (list :add (apply #'append (mapcar #'second seq))))
               ((or (list :into _) (list :add-tail _) (list :replace-tail _)
                    :keep-tail  :drop-tail)
                (first seq))))
           (rle-compress (diff)
             (-> diff
                 (group-by $ :predicate (lambda (e1 e2)
                                          (cond ((and (consp e1)
                                                      (consp e2)
                                                      (-> e1 first (eq $ :into) not))
                                                 (eq (car e1) (car e2)))
                                                (t (equal e1 e2)))))
                 (mapcar #'combine $)
                 (mapcar (lambda (elem)
                           (ematch elem
                             ((list :into arg) (list :into (rle-compress (second elem))))
                             (_ elem)))
                         $))))
    (rle-compress (longest-subseq list1 list2))))

(defun list-patch (list diff)
  (cond ((null diff) nil)
        (t (ematch (car diff)
             ((list :keep arg) (append (subseq list 0 arg)
                                       (list-patch (subseq list arg)
                                                   (cdr diff))))
             ((list :add arg) (append arg (list-patch list
                                                      (cdr diff))))
             ((list :drop arg) (list-patch (nthcdr arg list)
                                           (cdr diff)))
             (:drop-tail nil)
             (:keep-tail list)
             ((or (list :replace-tail arg)
                  (list :add-tail arg)) arg)
             ((list :into arg) (cons (list-patch (car list)
                                                 (-> diff first second))
                                     (list-patch (cdr list) (cdr diff))))))))

